// Code generated by protoc-gen-go. DO NOT EDIT.
// source: demo.proto

package demo

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type LiffRequest struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LiffRequest) Reset()         { *m = LiffRequest{} }
func (m *LiffRequest) String() string { return proto.CompactTextString(m) }
func (*LiffRequest) ProtoMessage()    {}
func (*LiffRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca53982754088a9d, []int{0}
}

func (m *LiffRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiffRequest.Unmarshal(m, b)
}
func (m *LiffRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiffRequest.Marshal(b, m, deterministic)
}
func (m *LiffRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiffRequest.Merge(m, src)
}
func (m *LiffRequest) XXX_Size() int {
	return xxx_messageInfo_LiffRequest.Size(m)
}
func (m *LiffRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LiffRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LiffRequest proto.InternalMessageInfo

func (m *LiffRequest) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type LiffResponse struct {
	ID                   int64    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Definition           string   `protobuf:"bytes,2,opt,name=Definition,proto3" json:"Definition,omitempty"`
	NodeID               string   `protobuf:"bytes,3,opt,name=NodeID,proto3" json:"NodeID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LiffResponse) Reset()         { *m = LiffResponse{} }
func (m *LiffResponse) String() string { return proto.CompactTextString(m) }
func (*LiffResponse) ProtoMessage()    {}
func (*LiffResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca53982754088a9d, []int{1}
}

func (m *LiffResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LiffResponse.Unmarshal(m, b)
}
func (m *LiffResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LiffResponse.Marshal(b, m, deterministic)
}
func (m *LiffResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiffResponse.Merge(m, src)
}
func (m *LiffResponse) XXX_Size() int {
	return xxx_messageInfo_LiffResponse.Size(m)
}
func (m *LiffResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LiffResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LiffResponse proto.InternalMessageInfo

func (m *LiffResponse) GetID() int64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *LiffResponse) GetDefinition() string {
	if m != nil {
		return m.Definition
	}
	return ""
}

func (m *LiffResponse) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

type Hello struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Hello) Reset()         { *m = Hello{} }
func (m *Hello) String() string { return proto.CompactTextString(m) }
func (*Hello) ProtoMessage()    {}
func (*Hello) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca53982754088a9d, []int{2}
}

func (m *Hello) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Hello.Unmarshal(m, b)
}
func (m *Hello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Hello.Marshal(b, m, deterministic)
}
func (m *Hello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hello.Merge(m, src)
}
func (m *Hello) XXX_Size() int {
	return xxx_messageInfo_Hello.Size(m)
}
func (m *Hello) XXX_DiscardUnknown() {
	xxx_messageInfo_Hello.DiscardUnknown(m)
}

var xxx_messageInfo_Hello proto.InternalMessageInfo

func (m *Hello) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Hello) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type There struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *There) Reset()         { *m = There{} }
func (m *There) String() string { return proto.CompactTextString(m) }
func (*There) ProtoMessage()    {}
func (*There) Descriptor() ([]byte, []int) {
	return fileDescriptor_ca53982754088a9d, []int{3}
}

func (m *There) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_There.Unmarshal(m, b)
}
func (m *There) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_There.Marshal(b, m, deterministic)
}
func (m *There) XXX_Merge(src proto.Message) {
	xxx_messageInfo_There.Merge(m, src)
}
func (m *There) XXX_Size() int {
	return xxx_messageInfo_There.Size(m)
}
func (m *There) XXX_DiscardUnknown() {
	xxx_messageInfo_There.DiscardUnknown(m)
}

var xxx_messageInfo_There proto.InternalMessageInfo

func (m *There) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *There) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*LiffRequest)(nil), "demo.LiffRequest")
	proto.RegisterType((*LiffResponse)(nil), "demo.LiffResponse")
	proto.RegisterType((*Hello)(nil), "demo.Hello")
	proto.RegisterType((*There)(nil), "demo.There")
}

func init() { proto.RegisterFile("demo.proto", fileDescriptor_ca53982754088a9d) }

var fileDescriptor_ca53982754088a9d = []byte{
	// 250 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x51, 0xc1, 0x4a, 0xc3, 0x40,
	0x14, 0x64, 0xd3, 0x5a, 0xf1, 0x45, 0x05, 0xdf, 0x41, 0x42, 0x41, 0x29, 0x39, 0x05, 0xc4, 0x52,
	0xf5, 0x0f, 0x34, 0x07, 0x03, 0xe2, 0x21, 0x15, 0xef, 0xd5, 0x4c, 0xec, 0x42, 0x92, 0x57, 0x77,
	0x57, 0x7f, 0xd0, 0x1f, 0x93, 0xdd, 0xa6, 0x10, 0xbc, 0xd8, 0xdb, 0xce, 0x9b, 0x79, 0xb3, 0x33,
	0xbb, 0x44, 0x15, 0x5a, 0x99, 0x6f, 0x8c, 0x38, 0xe1, 0xb1, 0x3f, 0xa7, 0x17, 0x14, 0x3f, 0xe9,
	0xba, 0x2e, 0xf1, 0xf9, 0x05, 0xeb, 0xf8, 0x94, 0xa2, 0x22, 0x4f, 0xd4, 0x4c, 0x65, 0xa3, 0x32,
	0x2a, 0xf2, 0xf4, 0x95, 0x8e, 0xb7, 0xb4, 0xdd, 0x48, 0x67, 0xf1, 0x97, 0xe7, 0x4b, 0xa2, 0x1c,
	0xb5, 0xee, 0xb4, 0xd3, 0xd2, 0x25, 0xd1, 0x4c, 0x65, 0x47, 0xe5, 0x60, 0xc2, 0xe7, 0x34, 0x79,
	0x96, 0x0a, 0x45, 0x9e, 0x8c, 0x02, 0xd7, 0xa3, 0xf4, 0x86, 0x0e, 0x1e, 0xd1, 0x34, 0xe2, 0x0d,
	0x75, 0xb5, 0x33, 0xd4, 0x15, 0x27, 0x74, 0xd8, 0xc2, 0xda, 0xd5, 0x07, 0x7a, 0xb7, 0x1d, 0xf4,
	0x2b, 0x2f, 0x6b, 0x18, 0xec, 0xbf, 0x72, 0xfb, 0xa3, 0x28, 0xce, 0xd1, 0xca, 0x12, 0xe6, 0x5b,
	0xbf, 0x83, 0xaf, 0x69, 0xec, 0xdb, 0xf0, 0xd9, 0x3c, 0xbc, 0xc3, 0xa0, 0xf8, 0x94, 0x87, 0xa3,
	0xbe, 0xec, 0x15, 0x9d, 0x3c, 0x34, 0x1a, 0x9d, 0x5b, 0x3a, 0x83, 0x55, 0x6b, 0x39, 0xde, 0x8a,
	0x42, 0xf2, 0x69, 0x0f, 0x42, 0xa6, 0x4c, 0x79, 0xb1, 0xbf, 0x06, 0xe6, 0x5f, 0xf1, 0xc2, 0x8b,
	0xe3, 0x7b, 0x71, 0xeb, 0x3d, 0x7c, 0x17, 0xea, 0x6d, 0x12, 0xfe, 0xeb, 0xee, 0x37, 0x00, 0x00,
	0xff, 0xff, 0x06, 0x12, 0x0b, 0x02, 0xbd, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DemoServiceClient is the client API for DemoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DemoServiceClient interface {
	// This method returns a line from one of the Liff books.
	Liff(ctx context.Context, in *LiffRequest, opts ...grpc.CallOption) (*LiffResponse, error)
	ClientStreams(ctx context.Context, opts ...grpc.CallOption) (DemoService_ClientStreamsClient, error)
	ServerStreams(ctx context.Context, in *Hello, opts ...grpc.CallOption) (DemoService_ServerStreamsClient, error)
	BothStreams(ctx context.Context, opts ...grpc.CallOption) (DemoService_BothStreamsClient, error)
}

type demoServiceClient struct {
	cc *grpc.ClientConn
}

func NewDemoServiceClient(cc *grpc.ClientConn) DemoServiceClient {
	return &demoServiceClient{cc}
}

func (c *demoServiceClient) Liff(ctx context.Context, in *LiffRequest, opts ...grpc.CallOption) (*LiffResponse, error) {
	out := new(LiffResponse)
	err := c.cc.Invoke(ctx, "/demo.DemoService/Liff", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *demoServiceClient) ClientStreams(ctx context.Context, opts ...grpc.CallOption) (DemoService_ClientStreamsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DemoService_serviceDesc.Streams[0], "/demo.DemoService/ClientStreams", opts...)
	if err != nil {
		return nil, err
	}
	x := &demoServiceClientStreamsClient{stream}
	return x, nil
}

type DemoService_ClientStreamsClient interface {
	Send(*Hello) error
	CloseAndRecv() (*There, error)
	grpc.ClientStream
}

type demoServiceClientStreamsClient struct {
	grpc.ClientStream
}

func (x *demoServiceClientStreamsClient) Send(m *Hello) error {
	return x.ClientStream.SendMsg(m)
}

func (x *demoServiceClientStreamsClient) CloseAndRecv() (*There, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(There)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *demoServiceClient) ServerStreams(ctx context.Context, in *Hello, opts ...grpc.CallOption) (DemoService_ServerStreamsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DemoService_serviceDesc.Streams[1], "/demo.DemoService/ServerStreams", opts...)
	if err != nil {
		return nil, err
	}
	x := &demoServiceServerStreamsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DemoService_ServerStreamsClient interface {
	Recv() (*There, error)
	grpc.ClientStream
}

type demoServiceServerStreamsClient struct {
	grpc.ClientStream
}

func (x *demoServiceServerStreamsClient) Recv() (*There, error) {
	m := new(There)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *demoServiceClient) BothStreams(ctx context.Context, opts ...grpc.CallOption) (DemoService_BothStreamsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DemoService_serviceDesc.Streams[2], "/demo.DemoService/BothStreams", opts...)
	if err != nil {
		return nil, err
	}
	x := &demoServiceBothStreamsClient{stream}
	return x, nil
}

type DemoService_BothStreamsClient interface {
	Send(*Hello) error
	Recv() (*There, error)
	grpc.ClientStream
}

type demoServiceBothStreamsClient struct {
	grpc.ClientStream
}

func (x *demoServiceBothStreamsClient) Send(m *Hello) error {
	return x.ClientStream.SendMsg(m)
}

func (x *demoServiceBothStreamsClient) Recv() (*There, error) {
	m := new(There)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DemoServiceServer is the server API for DemoService service.
type DemoServiceServer interface {
	// This method returns a line from one of the Liff books.
	Liff(context.Context, *LiffRequest) (*LiffResponse, error)
	ClientStreams(DemoService_ClientStreamsServer) error
	ServerStreams(*Hello, DemoService_ServerStreamsServer) error
	BothStreams(DemoService_BothStreamsServer) error
}

// UnimplementedDemoServiceServer can be embedded to have forward compatible implementations.
type UnimplementedDemoServiceServer struct {
}

func (*UnimplementedDemoServiceServer) Liff(ctx context.Context, req *LiffRequest) (*LiffResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Liff not implemented")
}
func (*UnimplementedDemoServiceServer) ClientStreams(srv DemoService_ClientStreamsServer) error {
	return status.Errorf(codes.Unimplemented, "method ClientStreams not implemented")
}
func (*UnimplementedDemoServiceServer) ServerStreams(req *Hello, srv DemoService_ServerStreamsServer) error {
	return status.Errorf(codes.Unimplemented, "method ServerStreams not implemented")
}
func (*UnimplementedDemoServiceServer) BothStreams(srv DemoService_BothStreamsServer) error {
	return status.Errorf(codes.Unimplemented, "method BothStreams not implemented")
}

func RegisterDemoServiceServer(s *grpc.Server, srv DemoServiceServer) {
	s.RegisterService(&_DemoService_serviceDesc, srv)
}

func _DemoService_Liff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DemoServiceServer).Liff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/demo.DemoService/Liff",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DemoServiceServer).Liff(ctx, req.(*LiffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DemoService_ClientStreams_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DemoServiceServer).ClientStreams(&demoServiceClientStreamsServer{stream})
}

type DemoService_ClientStreamsServer interface {
	SendAndClose(*There) error
	Recv() (*Hello, error)
	grpc.ServerStream
}

type demoServiceClientStreamsServer struct {
	grpc.ServerStream
}

func (x *demoServiceClientStreamsServer) SendAndClose(m *There) error {
	return x.ServerStream.SendMsg(m)
}

func (x *demoServiceClientStreamsServer) Recv() (*Hello, error) {
	m := new(Hello)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DemoService_ServerStreams_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Hello)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DemoServiceServer).ServerStreams(m, &demoServiceServerStreamsServer{stream})
}

type DemoService_ServerStreamsServer interface {
	Send(*There) error
	grpc.ServerStream
}

type demoServiceServerStreamsServer struct {
	grpc.ServerStream
}

func (x *demoServiceServerStreamsServer) Send(m *There) error {
	return x.ServerStream.SendMsg(m)
}

func _DemoService_BothStreams_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DemoServiceServer).BothStreams(&demoServiceBothStreamsServer{stream})
}

type DemoService_BothStreamsServer interface {
	Send(*There) error
	Recv() (*Hello, error)
	grpc.ServerStream
}

type demoServiceBothStreamsServer struct {
	grpc.ServerStream
}

func (x *demoServiceBothStreamsServer) Send(m *There) error {
	return x.ServerStream.SendMsg(m)
}

func (x *demoServiceBothStreamsServer) Recv() (*Hello, error) {
	m := new(Hello)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _DemoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "demo.DemoService",
	HandlerType: (*DemoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Liff",
			Handler:    _DemoService_Liff_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ClientStreams",
			Handler:       _DemoService_ClientStreams_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ServerStreams",
			Handler:       _DemoService_ServerStreams_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "BothStreams",
			Handler:       _DemoService_BothStreams_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "demo.proto",
}
